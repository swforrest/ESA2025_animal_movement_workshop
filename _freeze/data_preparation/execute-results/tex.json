{
  "hash": "0aa8b3eecbb2139f29063212cac639ce",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Preparation\"\n# author: \n#   - name: \"Scott Forrest\"\n#     url: https://swforrest.github.io/\n#     orcid: 0000-0001-9529-0108\n#     affiliation: Queensland University of Technology, CSIRO\n#     email: \"scottwforrest@gmail.com\"\ndate: today\nexecute: \n  cache: false\nbibliography: paperpile_references.bib\ntoc: true\nnumber-sections: false\nformat: \n  html:\n    self-contained: true\n    code-fold: show\n    code-tools: true\n    df-print: paged\n    code-line-numbers: true\n    code-overflow: scroll\n    fig-format: png\n    fig-dpi: 300\n  pdf:\n    geometry: \n      - top=30mm\n      - left=30mm\neditor:\n  source\nabstract: |\n  Here we do some basic data processing and prepare the spatial layers. \n---\n\n# Load packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(terra)\nlibrary(amt)\n```\n:::\n\n\n# Load data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndingo_data <- read_csv(\"data/tanami_collars.csv\") %>% filter(x > 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 61359 Columns: 53\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr  (13): dogname, sex, mine_away, gmt_date, gmt_time, cst_date, cst_month_...\ndbl  (38): x, y, dog_id, attempt_id, fix_id, cstmonth, cstmonth_cnt, csthour...\ntime  (2): cst_time, timemaxwindgist\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ndingo_data_sf <- st_as_sf(dingo_data, coords = c(\"x\", \"y\"), crs = 4326)\n```\n:::\n\n\n# Load shapefiles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nartificial_food <- st_read(\"spatial_layers/artificial_food/Art_Food_W84.shp\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Art_Food_W84' from data source \n  `/Users/scottforrest/Library/CloudStorage/OneDrive-QueenslandUniversityofTechnology/PhD - Scott Forrest/GIT/ESA2025_movement_ecology_hackathon/spatial_layers/artificial_food/Art_Food_W84.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 129.6909 ymin: -20.53831 xmax: 130.3135 ymax: -19.98017\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nartificial_water <- st_read(\"spatial_layers/artificial_water/ArtWater_W84v2.shp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ArtWater_W84v2' from data source \n  `/Users/scottforrest/Library/CloudStorage/OneDrive-QueenslandUniversityofTechnology/PhD - Scott Forrest/GIT/ESA2025_movement_ecology_hackathon/spatial_layers/artificial_water/ArtWater_W84v2.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 91 features and 16 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 129.0532 ymin: -20.74527 xmax: 130.9083 ymax: -19.10321\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nroads <- st_read(\"spatial_layers/roads/RM_rds_trks_clip.shp\") %>% \n  st_transform(crs = st_crs(artificial_food))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `RM_rds_trks_clip' from data source \n  `/Users/scottforrest/Library/CloudStorage/OneDrive-QueenslandUniversityofTechnology/PhD - Scott Forrest/GIT/ESA2025_movement_ecology_hackathon/spatial_layers/roads/RM_rds_trks_clip.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1004 features and 1 field\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 515871.5 ymin: 7696050 xmax: 713746.3 ymax: 7829996\nProjected CRS: GDA94 / MGA zone 52\n```\n\n\n:::\n:::\n\n\n## Plot the shapefiles with dingo GPS data\n\nDingo locations are shown in a different colour for each ID.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = roads, color = \"black\") +\n  geom_sf(data = artificial_water, color = \"blue\") +\n  geom_sf(data = artificial_food, color = \"red\") +\n  geom_sf(data = dingo_data_sf, aes(color = as.factor(dog_id)), size = 0.25, alpha = 0.25) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Create an AOI for downloading DEM\n\nWe can go to this website <https://elevation.fsdf.org.au/> to download a DEM for our area of interest (AOI). To do this, we first need to create a rectangle JSON that defines the AOI based on the GPS locations of the dingoes. We will add a buffer around the min and max coordinates to ensure we capture the full area.\n\nIn this chunk we create a function that can take a GPS dataset, pull out the location columns to find a max and min in both lat and long (or easting and northing), add a buffer, and create a rectangle polygon shapefile and geojson file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to create rectangle from coordinate bounds\ncreate_rectangle_shapefile <- function(df, x_col = \"x\", y_col = \"y\", \n                                       buffer = 0.05, crs = 4326, \n                                       output_path = \"rectangle\") {\n  \n  # Calculate bounds with buffer\n  min_x <- min(df[[x_col]], na.rm = TRUE) - buffer\n  max_x <- max(df[[x_col]], na.rm = TRUE) + buffer\n  min_y <- min(df[[y_col]], na.rm = TRUE) - buffer\n  max_y <- max(df[[y_col]], na.rm = TRUE) + buffer\n  \n  # Create rectangle coordinates (clockwise from bottom-left)\n  rectangle_coords <- matrix(c(\n    min_x, min_y,  # bottom-left\n    max_x, min_y,  # bottom-right\n    max_x, max_y,  # top-right\n    min_x, max_y,  # top-left\n    min_x, min_y   # close the polygon\n  ), ncol = 2, byrow = TRUE)\n  \n  # Create polygon geometry\n  rectangle_poly <- st_polygon(list(rectangle_coords))\n  \n  # Create sf object\n  rectangle_sf <- st_sf(\n    id = 1,\n    area = st_area(rectangle_poly),\n    geometry = st_sfc(rectangle_poly, crs = crs)\n  )\n  \n  rectangle_projected <- st_transform(rectangle_sf, crs = 4326) \n  \n  # Export as shapefile\n  st_write(rectangle_projected, paste0(output_path, \".shp\"), \n           delete_dsn = TRUE, quiet = TRUE)\n  \n  # Also export as GeoJSON (alternative format)\n  st_write(rectangle_projected, paste0(output_path, \".geojson\"), \n           delete_dsn = TRUE, quiet = TRUE)\n  \n  # Print summary\n  cat(\"Rectangle created with bounds:\\n\")\n  cat(\"X range:\", min_x, \"to\", max_x, \"\\n\")\n  cat(\"Y range:\", min_y, \"to\", max_y, \"\\n\")\n  cat(\"Files saved:\", paste0(output_path, \".shp\"), \"and\", paste0(output_path, \".geojson\"), \"\\n\")\n  \n  return(rectangle_projected)\n}\n```\n:::\n\n\n### Use function to create shapefile and geojson\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the rectangle shapefile\ndingo_extent <- create_rectangle_shapefile(\n  df = dingo_data,\n  x_col = \"x\",             # column name for easting/longitude\n  y_col = \"y\",             # column name for northing/latitude\n  buffer = 0.1,           # buffer distance in coordinate units (degrees or m)\n  crs = 4326,              # coordinate reference system of GPS locations (will output in 4326)\n  output_path = \"spatial_layers/extent/dingo_extent\" # without extension\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRectangle created with bounds:\nX range: 129.7193 to 131.4602 \nY range: -20.95433 to -20.09433 \nFiles saved: spatial_layers/extent/dingo_extent.shp and spatial_layers/extent/dingo_extent.geojson \n```\n\n\n:::\n\n```{.r .cell-code}\n# View the result\nprint(dingo_extent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 129.7194 ymin: -20.95433 xmax: 131.4602 ymax: -20.09433\nGeodetic CRS:  WGS 84\n  id     area                       geometry\n1  1 1.497153 POLYGON ((129.7193 -20.9543...\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a sf object\ndingo_extent_sf <- st_geometry(dingo_extent)\n\n# Optional: Add your original points to the plot\nplot(dingo_extent_sf, main = \"Rectangle with Original Points\")\nplot(st_geometry(dingo_data_sf), add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Check DEM\n\nWe downloaded the DEM from [Geoscience Australia](https://elevation.fsdf.org.au/), which is a 1 second resolution DEM for Australia. We will use this to create slope and roughness layers. We will .\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the DEM\ndem <- terra::rast(\"spatial_layers/topography/Hydro_Enforced_1_Second_DEM.tif\") # hydro-enforced DEM\ndem\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 3096, 6267, 1  (nrow, ncol, nlyr)\nresolution  : 0.0002777778, 0.0002777778  (x, y)\nextent      : 129.7193, 131.4601, -20.95431, -20.09431  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : Hydro_Enforced_1_Second_DEM.tif \nname        : Hydro_Enforced_1_Second_DEM \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(dem)\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n## Create slope layer\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# # create slope layer\n# slope <- terra::terrain(dem, v = \"slope\", unit = \"degrees\", neighbors = 8)\n# plot(slope)\n# # save the layer\n# terra::writeRaster(slope, \"spatial_layers/topography/slope.tif\", overwrite = T)\n\n# load slope\nslope <- terra::rast(\"spatial_layers/topography/slope.tif\")\nplot(slope)\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Clip the spatial layers to the dingo extent\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# clip artificial food layer\nartificial_food_clipped <- st_intersection(artificial_food, dingo_extent_sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n```\n\n\n:::\n\n```{.r .cell-code}\n# clip artificial water layer\nartificial_water_clipped <- st_intersection(artificial_water, dingo_extent_sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n```\n\n\n:::\n\n```{.r .cell-code}\n# clip the roads layer\nroads_clipped <- st_intersection(roads, dingo_extent_sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n```\n\n\n:::\n:::\n\n\n## Plot the clipped layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = roads_clipped, color = \"black\") +\n  geom_sf(data = dingo_data_sf, aes(color = as.factor(dog_id)), size = 0.5, alpha = 0.25) +\n  geom_sf(data = artificial_water_clipped, color = \"blue\") +\n  geom_sf(data = artificial_food_clipped, color = \"red\") +\n  scale_colour_viridis_d(\"Dingo ID\") +\n  theme_bw() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nggsave(\"figures/gps_locations_vector_objects.png\", width = 150, height = 100, units = \"mm\", dpi = 600)\n```\n:::\n\n\n# Create distance covariates\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# # create distance to artificial food layer\n# artificial_food_raster <- terra::rasterize(vect(artificial_food_clipped), dem, field = 1, background = NA)\n# dist_artificial_food <- terra::distance(artificial_food_raster)\n# plot(dist_artificial_food, main = \"Distance to Artificial Food\")\n# terra::writeRaster(dist_artificial_food, \"spatial_layers/artificial_food/dist_artificial_food.tif\", overwrite = T)\n# \n# # create distance to artificial water layer\n# artificial_water_raster <- terra::rasterize(vect(artificial_water_clipped), dem, field = 1, background = NA)\n# dist_artificial_water <- terra::distance(artificial_water_raster)\n# plot(dist_artificial_water, main = \"Distance to Artificial Water\")\n# terra::writeRaster(dist_artificial_water, \"spatial_layers/artificial_water/dist_artificial_water.tif\", overwrite = T)\n# \n# # create distance to roads layer\n# roads_raster <- terra::rasterize(vect(roads_clipped), dem, field = 1, background = NA)\n# dist_roads <- terra::distance(roads_raster)\n# plot(dist_roads, main = \"Distance to Roads\")\n# terra::writeRaster(dist_roads, \"spatial_layers/roads/dist_roads.tif\", overwrite = T)\n```\n:::\n\n\n## Load distance layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load distance to artificial food layer\ndist_artificial_food <- terra::rast(\"spatial_layers/artificial_food/dist_artificial_food.tif\")\nplot(dist_artificial_food, main = \"Distance to Artificial Food\")\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# load distance to artificial water layer\ndist_artificial_water <- terra::rast(\"spatial_layers/artificial_water/dist_artificial_water.tif\")\nplot(dist_artificial_water, main = \"Distance to Artificial Water\")\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-12-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# load distance to roads layer\ndist_roads <- terra::rast(\"spatial_layers/roads/dist_roads.tif\")\nplot(dist_roads, main = \"Distance to Roads\")\n```\n\n::: {.cell-output-display}\n![](data_preparation_files/figure-pdf/unnamed-chunk-12-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n# References\n\n::: {#refs}\n:::\n",
    "supporting": [
      "data_preparation_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}